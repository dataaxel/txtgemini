<script>
    let model;
    let metadata;

    // --- INSTÄLLNINGAR ---
    // Om du laddade upp hela mappen 'tfjs_model' på GitHub, ändra raden nedan till:
    // const MODEL_PATH = 'tfjs_model/';
    const MODEL_PATH = 'tfjs_model/'; 
    // ---------------------

    async function loadModel() {
        const statusEl = document.getElementById('loadingStatus');
        const btn = document.getElementById('analyzeBtn');
        const errBox = document.getElementById('errorBox');

        try {
            // Bygg sökvägar
            const modelUrl = MODEL_PATH + 'model.json';
            const metadataUrl = MODEL_PATH + 'metadata.json';

            console.log(`Försöker ladda modell från: ${modelUrl}`);

            // 1. Ladda modellen
            model = await tf.loadLayersModel(modelUrl);
            
            // 2. Ladda metadata
            const metadataResponse = await fetch(metadataUrl);
            if (!metadataResponse.ok) {
                throw new Error(`Kunde inte hitta metadata.json på adressen: ${metadataUrl} (Status: ${metadataResponse.status})`);
            }
            metadata = await metadataResponse.json();

            statusEl.innerText = "Modell redo!";
            statusEl.style.color = "green";
            btn.disabled = false;
            console.log("Modell och metadata laddat.");

        } catch (error) {
            console.error(error);
            statusEl.style.display = 'none';
            errBox.style.display = 'block';
            // Visa ett tydligt felmeddelande för användaren
            errBox.innerHTML = `
                <strong>Fel vid laddning:</strong><br>
                ${error.message}<br><br>
                <em>Tips: Kontrollera din GitHub-filstruktur. <br>
                Om filerna ligger i en mapp (t.ex. 'tfjs_model'), måste du uppdatera variabeln MODEL_PATH i koden.</em>
            `;
        }
    }

    loadModel();

    // Tokenizer-funktion
    function tokenize(text) {
        const words = text.toLowerCase().replace(/[.,!?;:()]/g, '').split(/\s+/);
        const sequence = [];
        const oovIndex = metadata.word_index[metadata.oov_token] || 1; 

        words.forEach(word => {
            if (word) {
                const index = metadata.word_index[word];
                sequence.push(index !== undefined ? index : oovIndex);
            }
        });
        return sequence;
    }

    // Padding-funktion
    function padSequence(sequence) {
        const maxLen = metadata.max_length;
        if (sequence.length > maxLen) {
            return sequence.slice(0, maxLen);
        } else {
            const padCount = maxLen - sequence.length;
            const padded = [...sequence];
            for (let i = 0; i < padCount; i++) {
                padded.push(0);
            }
            return padded;
        }
    }

    // Prediktion
    async function predict() {
        const text = document.getElementById('inputText').value;
        const resultBox = document.getElementById('resultBox');
        const errorBox = document.getElementById('errorBox');
        
        errorBox.style.display = 'none';
        
        if (!text.trim()) {
            alert("Skriv in text först.");
            return;
        }

        try {
            const sequence = tokenize(text);
            const padded = padSequence(sequence);
            const inputTensor = tf.tensor2d([padded], [1, metadata.max_length]);

            const prediction = model.predict(inputTensor);
            const data = await prediction.data(); 
            
            const maxIndex = data.indexOf(Math.max(...data));
            const labels = metadata.labels; 
            
            const resultText = document.getElementById('predictionResult');
            resultText.innerText = `Bedömning: ${labels[maxIndex].toUpperCase()}`;
            
            if(labels[maxIndex] === 'positiv') resultText.style.color = 'green';
            else if(labels[maxIndex] === 'negativ') resultText.style.color = 'red';
            else resultText.style.color = '#888';

            const probContainer = document.getElementById('probabilities');
            probContainer.innerHTML = ''; 
            
            labels.forEach((label, idx) => {
                const percentage = (data[idx] * 100).toFixed(1);
                const div = document.createElement('div');
                div.className = 'prob-bar-container';
                div.innerHTML = `
                    <div class="prob-label"><span>${label}</span><span>${percentage}%</span></div>
                    <div class="prob-bar">
                        <div class="prob-fill" style="width: ${percentage}%; background-color: ${getColor(label)}"></div>
                    </div>
                `;
                probContainer.appendChild(div);
            });

            resultBox.style.display = 'block';
            inputTensor.dispose();
            prediction.dispose();

        } catch (err) {
            console.error(err);
            errorBox.style.display = 'block';
            errorBox.innerText = "Ett fel uppstod vid analysen: " + err.message;
        }
    }

    function getColor(label) {
        if(label === 'positiv') return '#4CAF50';
        if(label === 'negativ') return '#F44336';
        return '#9E9E9E'; 
    }
</script>
